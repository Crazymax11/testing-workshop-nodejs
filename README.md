# Репозиторий с мастер-классом по тестированию nodejs

в мастере лежит код, с которым мы начинаем МК
в ветке kontur - то что пришли на офлайн МК в офисе контура

## Задача

Мы делаем проксирующий bff. Пользователь делает к нам запрос на `/users/:id`, bff проксирует этот запрос на другое API, мапит поля, и отдает пользователю.
Если с API пришло 400 или 500 - bff должен запроксировать эту 400 или 500 ошибку

### Дополнение 1

После реализации задачи, нужно внести правки. Теперь, если пользователь передал флаг isShort=true, то bff должен отдать при мапинге только id и name. Если isShort=false или не указан, отдаются полные данные. Если isShort невалидный - отдаем 400

### Дополнение 2

Теперь нужно уметь отдавать список пользователей, поддержав флаг `isShort`.

## Используемые инструменты

- [koa.js](https://koajs.com/) - nodejs фреймворк
- [axios](https://github.com/axios/axios) - библиотека для http запросов
- [supertest](https://www.npmjs.com/package/supertest) - фреймворковнезависимый инструмент для тестирования nodejs сервирсв
- [nock.js](https://github.com/nock/nock) - фреймворковнезависимый инструмент для тестирования http запросов

## Принципы тестирования

### Фазы теста

Фазы теста в разных источниках могут называться по разному, но все способы структурирования фаз тестов сводятся к следующим фазам:

- установка/настройка окружения
- запуск тестируемого функционала
- проверка, что функционал отработал как ожидалось
- очистка окружения

В существующих схемах устаноку и очистку окружения могут называть setup и teardown.
Есть схема AAA - arrange(настройка) act(действие) assert(проверка).
Есть GWT - Given When Then, используемая, в основном, в BDD.

### Знания в названии теста

Каждый тест содержитт в своем названии как минимум 2 знания:

- что тестируем
- что ожидаем

Также для части тестов добавляется 3 знание:

- в каком контексте

Как правило, в JS фреймворках блоки `describe` отвечают на вопрос _что тестируем_, а `it` на _что ожидаем_ и _в каком контексте_

```js
describe("users", () => {
  describe("GET /users/:id", () => {
    it("должен ответить 400 кодом, если переданный параметр isShort не является boolean", () => {});
  });
});
```

Это позволяет:

- мапить требования к разработке на тесты
- по названию упавщего теста понять, какой функционал сломался
- лучше понять, что тестируется, если тело теста - сложное или непонятное

### Data Driven тесты

Часто бывает, что тесты получаются очень однотипными. В этом случае можно описывать тесты массивом входящих и выходящих данныхю

```js
const specs = [
  {
    input: {
      userType: "manager",
      targetType: "employee",
    },
    expected: {
      status: 200,
    },
  },
].forEach((spec) =>
  it(`должен ответить ${spec.expected.status}, если ${spec.input.userType} пытается поменять данные ${spec.input.targetType}`, () => {})
);
```

Что нужно знать при применении этого подхода:

- название теста должно складываться из данных теста
- в теле теста не должно быть if'ов. Если внутри теста if - значит вы делаете что-то не так. Стоит подумать о том, чтобы унести if в данные теста, либо признать, что тесты, ради которых вводится if - не похожи на тесты, для которых if не делается.

Этот подход можно улучшить, применяя резолверы данных. Но, как правило, и обычные массивы с фикстурами справляются хорошо.
